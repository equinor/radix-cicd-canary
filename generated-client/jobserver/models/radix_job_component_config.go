// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// RadixJobComponentConfig RadixJobComponentConfig holds description of RadixJobComponent
//
// swagger:model RadixJobComponentConfig
type RadixJobComponentConfig struct {

	// Arguments to the entrypoint.
	// The container image's CMD is used if this is not provided.
	// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
	// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
	// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
	// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
	// of whether the variable exists or not. Cannot be updated.
	// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	// +optional
	// +listType=atomic
	Args []string `json:"args"`

	// BackoffLimit defines attempts to restart job if it fails. Corresponds to BackoffLimit in K8s.
	BackoffLimit int32 `json:"backoffLimit,omitempty"`

	// Entrypoint array. Not executed within a shell.
	// The container image's ENTRYPOINT is used if this is not provided.
	// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
	// cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
	// to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
	// produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
	// of whether the variable exists or not. Cannot be updated.
	// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
	// +optional
	// +listType=atomic
	Command []string `json:"command"`

	// Name of an existing container image to use when running the job. Overrides an image in the RadixDeployment
	// More info: https://www.radix.equinor.com/radix-config#image-2
	// +optional
	Image string `json:"image,omitempty"`

	// ImageTagName defines the image tag name to use for the job image
	ImageTagName string `json:"imageTagName,omitempty"`

	// TimeLimitSeconds defines maximum job run time. Corresponds to ActiveDeadlineSeconds in K8s.
	TimeLimitSeconds int64 `json:"timeLimitSeconds,omitempty"`

	// failure policy
	FailurePolicy *FailurePolicy `json:"failurePolicy,omitempty"`

	// node
	Node *Node `json:"node,omitempty"`

	// resources
	Resources *Resources `json:"resources,omitempty"`

	// runtime
	Runtime *Runtime `json:"runtime,omitempty"`

	// variables
	Variables EnvVars `json:"variables,omitempty"`
}

// Validate validates this radix job component config
func (m *RadixJobComponentConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateFailurePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResources(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRuntime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVariables(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RadixJobComponentConfig) validateFailurePolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.FailurePolicy) { // not required
		return nil
	}

	if m.FailurePolicy != nil {
		if err := m.FailurePolicy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("failurePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("failurePolicy")
			}
			return err
		}
	}

	return nil
}

func (m *RadixJobComponentConfig) validateNode(formats strfmt.Registry) error {
	if swag.IsZero(m.Node) { // not required
		return nil
	}

	if m.Node != nil {
		if err := m.Node.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *RadixJobComponentConfig) validateResources(formats strfmt.Registry) error {
	if swag.IsZero(m.Resources) { // not required
		return nil
	}

	if m.Resources != nil {
		if err := m.Resources.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resources")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("resources")
			}
			return err
		}
	}

	return nil
}

func (m *RadixJobComponentConfig) validateRuntime(formats strfmt.Registry) error {
	if swag.IsZero(m.Runtime) { // not required
		return nil
	}

	if m.Runtime != nil {
		if err := m.Runtime.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("runtime")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("runtime")
			}
			return err
		}
	}

	return nil
}

func (m *RadixJobComponentConfig) validateVariables(formats strfmt.Registry) error {
	if swag.IsZero(m.Variables) { // not required
		return nil
	}

	if m.Variables != nil {
		if err := m.Variables.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("variables")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("variables")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this radix job component config based on the context it is used
func (m *RadixJobComponentConfig) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateFailurePolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResources(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRuntime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVariables(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RadixJobComponentConfig) contextValidateFailurePolicy(ctx context.Context, formats strfmt.Registry) error {

	if m.FailurePolicy != nil {

		if swag.IsZero(m.FailurePolicy) { // not required
			return nil
		}

		if err := m.FailurePolicy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("failurePolicy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("failurePolicy")
			}
			return err
		}
	}

	return nil
}

func (m *RadixJobComponentConfig) contextValidateNode(ctx context.Context, formats strfmt.Registry) error {

	if m.Node != nil {

		if swag.IsZero(m.Node) { // not required
			return nil
		}

		if err := m.Node.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("node")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("node")
			}
			return err
		}
	}

	return nil
}

func (m *RadixJobComponentConfig) contextValidateResources(ctx context.Context, formats strfmt.Registry) error {

	if m.Resources != nil {

		if swag.IsZero(m.Resources) { // not required
			return nil
		}

		if err := m.Resources.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resources")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("resources")
			}
			return err
		}
	}

	return nil
}

func (m *RadixJobComponentConfig) contextValidateRuntime(ctx context.Context, formats strfmt.Registry) error {

	if m.Runtime != nil {

		if swag.IsZero(m.Runtime) { // not required
			return nil
		}

		if err := m.Runtime.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("runtime")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("runtime")
			}
			return err
		}
	}

	return nil
}

func (m *RadixJobComponentConfig) contextValidateVariables(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.Variables) { // not required
		return nil
	}

	if err := m.Variables.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("variables")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("variables")
		}
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RadixJobComponentConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RadixJobComponentConfig) UnmarshalBinary(b []byte) error {
	var res RadixJobComponentConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
